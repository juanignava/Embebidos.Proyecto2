
alarm.elf:     file format elf32-littlenios2
alarm.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00002020

Program Header:
    LOAD off    0x00001000 vaddr 0x00002000 paddr 0x00002000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x00002020 paddr 0x00002020 align 2**12
         filesz 0x00000c70 memsz 0x00000c70 flags r-x
    LOAD off    0x00001c90 vaddr 0x00002c90 paddr 0x00002ccc align 2**12
         filesz 0x0000003c memsz 0x0000003c flags rw-
    LOAD off    0x00001d08 vaddr 0x00002d08 paddr 0x00002d08 align 2**12
         filesz 0x00000000 memsz 0x00000124 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  00002000  00002000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000000  00002020  00002020  00001ccc  2**0
                  CONTENTS
  2 .text         00000bcc  00002020  00002020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       000000a4  00002bec  00002bec  00001bec  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       0000003c  00002c90  00002ccc  00001c90  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          00000124  00002d08  00002d08  00001d08  2**2
                  ALLOC, SMALL_DATA
  6 .RAM          00000000  00002e2c  00002e2c  00001ccc  2**0
                  CONTENTS
  7 .comment      0000002d  00000000  00000000  00001ccc  2**0
                  CONTENTS, READONLY
  8 .debug_aranges 000001f0  00000000  00000000  00001d00  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  9 .debug_info   00001e6a  00000000  00000000  00001ef0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 10 .debug_abbrev 00000dc8  00000000  00000000  00003d5a  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_line   000018cf  00000000  00000000  00004b22  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_frame  0000039c  00000000  00000000  000063f4  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_str    00000a2e  00000000  00000000  00006790  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_loc    000011c0  00000000  00000000  000071be  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_alt_sim_info 00000010  00000000  00000000  00008380  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_ranges 000001f8  00000000  00000000  00008390  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .thread_model 00000003  00000000  00000000  000097ab  2**0
                  CONTENTS, READONLY
 18 .cpu          00000003  00000000  00000000  000097ae  2**0
                  CONTENTS, READONLY
 19 .qsys         00000001  00000000  00000000  000097b1  2**0
                  CONTENTS, READONLY
 20 .simulation_enabled 00000001  00000000  00000000  000097b2  2**0
                  CONTENTS, READONLY
 21 .stderr_dev   00000004  00000000  00000000  000097b3  2**0
                  CONTENTS, READONLY
 22 .stdin_dev    00000004  00000000  00000000  000097b7  2**0
                  CONTENTS, READONLY
 23 .stdout_dev   00000004  00000000  00000000  000097bb  2**0
                  CONTENTS, READONLY
 24 .sopc_system_name 0000000b  00000000  00000000  000097bf  2**0
                  CONTENTS, READONLY
 25 .quartus_project_dir 00000027  00000000  00000000  000097ca  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00002000 l    d  .entry	00000000 .entry
00002020 l    d  .exceptions	00000000 .exceptions
00002020 l    d  .text	00000000 .text
00002bec l    d  .rodata	00000000 .rodata
00002c90 l    d  .rwdata	00000000 .rwdata
00002d08 l    d  .bss	00000000 .bss
00002e2c l    d  .RAM	00000000 .RAM
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 c:/quartus_embebidos/Embebidos.Project2/software/alarm_bsp//obj/HAL/src/crt0.o
00002058 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 hello_world_small.c
0000205c l     F .text	00000044 btn_down_respond
000020a0 l     F .text	00000044 btn_up_respond
000020e4 l     F .text	000000e4 btn_set_respond
00002494 l     F .text	000000f8 timer_respond
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 alt_load.c
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_printf.c
00000000 l    df *ABS*	00000000 alt_putchar.c
00000000 l    df *ABS*	00000000 alt_putstr.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 strlen.c
00002954 g     F .text	0000002c alt_main
00002d2c g     O .bss	00000100 alt_irq
00002ccc g       *ABS*	00000000 __flash_rwdata_start
00002cc8 g     O .rwdata	00000004 UART
0000258c g     F .text	0000003c init_values
00002b0c g     F .text	00000038 alt_putstr
00002ba0 g     F .text	00000008 altera_nios2_gen2_irq_init
00002000 g     F .entry	0000000c __reset
00002cc0 g     O .rwdata	00000004 h0_ptr
00002020 g       *ABS*	00000000 __flash_exceptions_start
00002cbc g     O .rwdata	00000004 m1_ptr
00002d24 g     O .bss	00000004 alt_argv
0000ac90 g       *ABS*	00000000 _gp
00002ba8 g     F .text	00000028 memcpy
00002cb0 g     O .rwdata	00000004 s0_ptr
00002ca4 g     O .rwdata	00000004 down_ptr
00002810 g     F .text	00000064 .hidden __udivsi3
00002cb8 g     O .rwdata	00000004 m0_ptr
00002228 g     F .text	00000090 alt_irq_register
00002e2c g       *ABS*	00000000 __bss_end
00002d16 g     O .bss	00000006 alarm
00002d1c g     O .bss	00000004 alt_irq_active
00002c9c g     O .rwdata	00000004 swc_alarm
00002d0b g     O .bss	00000001 up_pressed
00002ca0 g     O .rwdata	00000004 swc_sel
00002b98 g     F .text	00000004 alt_dcache_flush_all
00002cb4 g     O .rwdata	00000004 s1_ptr
00002ccc g       *ABS*	00000000 __ram_rwdata_end
00002c90 g       *ABS*	00000000 __ram_rodata_end
00002874 g     F .text	0000005c .hidden __umodsi3
00002e2c g       *ABS*	00000000 end
00004000 g       *ABS*	00000000 __alt_stack_pointer
00002b68 g     F .text	00000030 altera_avalon_jtag_uart_write
00002980 g     F .text	00000140 alt_printf
00002ca8 g     O .rwdata	00000004 up_ptr
00002020 g     F .text	0000003c _start
00002b64 g     F .text	00000004 alt_sys_init
00002cc4 g     O .rwdata	00000004 h1_ptr
00002c92 g     O .rwdata	00000002 time_unit_sel
00002c90 g       *ABS*	00000000 __ram_rwdata_start
00002bec g       *ABS*	00000000 __ram_rodata_start
00002d10 g     O .bss	00000006 hour
00002e2c g       *ABS*	00000000 __alt_stack_base
000023bc g     F .text	00000064 add_second
00002d0a g     O .bss	00000001 down_pressed
00002d0d g     O .bss	00000001 irqtimer_stall
00002d08 g       *ABS*	00000000 __bss_start
000025c8 g     F .text	00000154 main
00002000 g       *ABS*	00000000 __alt_mem_RAM
00002d20 g     O .bss	00000004 alt_envp
00002d08 g     O .bss	00000001 button_pressed
0000271c g     F .text	00000080 .hidden __divsi3
00002350 g     F .text	0000006c set_value
00002bec g       *ABS*	00000000 __flash_rodata_start
00002c94 g     O .rwdata	00000004 timer_base_ptr
00002cac g     O .rwdata	00000004 set_clock
00002b44 g     F .text	00000020 alt_irq_init
00002c98 g     O .rwdata	00000004 alarm_ptr
00002d28 g     O .bss	00000004 alt_argc
000021c8 g     F .text	00000060 irq_handler
00002420 g     F .text	00000074 display_hour
00002020 g       *ABS*	00000000 __ram_exceptions_start
00002c90 g     O .rwdata	00000001 first
00002ccc g       *ABS*	00000000 _edata
00002e2c g       *ABS*	00000000 _end
00002020 g       *ABS*	00000000 __ram_exceptions_end
0000279c g     F .text	00000074 .hidden __modsi3
00004000 g       *ABS*	00000000 __alt_data_end
00002d0e g     O .bss	00000002 is_activated
0000200c g       .entry	00000000 _exit
00002d09 g     O .bss	00000001 set_pressed
000022b8 g     F .text	00000098 numberToSeg7
00002bd0 g     F .text	0000001c strlen
00002ac0 g     F .text	0000004c alt_putchar
00002b9c g     F .text	00000004 alt_icache_flush_all
00002d0c g     O .bss	00000001 ud_buttons_en
000028d0 g     F .text	00000084 alt_load



Disassembly of section .entry:

00002000 <__reset>:
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
    2000:	00400034 	movhi	at,0
    ori r1, r1, %lo(_start)
    2004:	08480814 	ori	at,at,8224
    jmp r1
    2008:	0800683a 	jmp	at

0000200c <_exit>:
	...

Disassembly of section .text:

00002020 <_start>:

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
    2020:	06c00034 	movhi	sp,0
    ori sp, sp, %lo(__alt_stack_pointer)
    2024:	ded00014 	ori	sp,sp,16384
    movhi gp, %hi(_gp)
    2028:	06800034 	movhi	gp,0
    ori gp, gp, %lo(_gp)
    202c:	d6ab2414 	ori	gp,gp,44176
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
    2030:	00800034 	movhi	r2,0
    ori r2, r2, %lo(__bss_start)
    2034:	108b4214 	ori	r2,r2,11528

    movhi r3, %hi(__bss_end)
    2038:	00c00034 	movhi	r3,0
    ori r3, r3, %lo(__bss_end)
    203c:	18cb8b14 	ori	r3,r3,11820

    beq r2, r3, 1f
    2040:	10c00326 	beq	r2,r3,2050 <_start+0x30>

0:
    stw zero, (r2)
    2044:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
    2048:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
    204c:	10fffd36 	bltu	r2,r3,2044 <_start+0x24>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
    2050:	00028d00 	call	28d0 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
    2054:	00029540 	call	2954 <alt_main>

00002058 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
    2058:	003fff06 	br	2058 <alt_after_alt_main>

0000205c <btn_down_respond>:
 */
static void btn_down_respond(void* context, alt_u32 id) {
	//logica del boton down.

	/* Acknowledge interrupt by clearing edge capture register */
	*(down_ptr + 12) = 0;
    205c:	d0a00517 	ldw	r2,-32748(gp)
    2060:	10000305 	stb	zero,12(r2)

	if (!down_pressed) {
    2064:	d0a01e83 	ldbu	r2,-32646(gp)
    2068:	10000a1e 	bne	r2,zero,2094 <btn_down_respond+0x38>
		alt_putstr("Button down\n");
    206c:	01000034 	movhi	r4,0
static void btn_down_respond(void* context, alt_u32 id) {
    2070:	deffff04 	addi	sp,sp,-4
		alt_putstr("Button down\n");
    2074:	210afb04 	addi	r4,r4,11244
static void btn_down_respond(void* context, alt_u32 id) {
    2078:	dfc00015 	stw	ra,0(sp)
		alt_putstr("Button down\n");
    207c:	0002b0c0 	call	2b0c <alt_putstr>
		down_pressed = TRUE;
    2080:	00800044 	movi	r2,1
    2084:	d0a01e85 	stb	r2,-32646(gp)

	} else {
		alt_putstr("Button already set down\n");
	}
}
    2088:	dfc00017 	ldw	ra,0(sp)
    208c:	dec00104 	addi	sp,sp,4
    2090:	f800283a 	ret
		alt_putstr("Button already set down\n");
    2094:	01000034 	movhi	r4,0
    2098:	210aff04 	addi	r4,r4,11260
    209c:	0002b0c1 	jmpi	2b0c <alt_putstr>

000020a0 <btn_up_respond>:
	*(up_ptr + 12) = 0;
    20a0:	d0a00617 	ldw	r2,-32744(gp)
    20a4:	10000305 	stb	zero,12(r2)
	if (!up_pressed) {
    20a8:	d0a01ec3 	ldbu	r2,-32645(gp)
    20ac:	10000a1e 	bne	r2,zero,20d8 <btn_up_respond+0x38>
		alt_putstr("Button up\n");
    20b0:	01000034 	movhi	r4,0
static void btn_up_respond(void* context, alt_u32 id){
    20b4:	deffff04 	addi	sp,sp,-4
		alt_putstr("Button up\n");
    20b8:	210b0604 	addi	r4,r4,11288
static void btn_up_respond(void* context, alt_u32 id){
    20bc:	dfc00015 	stw	ra,0(sp)
		alt_putstr("Button up\n");
    20c0:	0002b0c0 	call	2b0c <alt_putstr>
		up_pressed = TRUE;
    20c4:	00800044 	movi	r2,1
    20c8:	d0a01ec5 	stb	r2,-32645(gp)
}
    20cc:	dfc00017 	ldw	ra,0(sp)
    20d0:	dec00104 	addi	sp,sp,4
    20d4:	f800283a 	ret
		alt_putstr("Button already set up\n");
    20d8:	01000034 	movhi	r4,0
    20dc:	210b0904 	addi	r4,r4,11300
    20e0:	0002b0c1 	jmpi	2b0c <alt_putstr>

000020e4 <btn_set_respond>:
	*alarm_ptr = (unsigned char) 0;
    20e4:	d0a00217 	ldw	r2,-32760(gp)
	up_pressed = FALSE;
    20e8:	d0201ec5 	stb	zero,-32645(gp)
	down_pressed = FALSE;
    20ec:	d0201e85 	stb	zero,-32646(gp)
	*alarm_ptr = (unsigned char) 0;
    20f0:	10000005 	stb	zero,0(r2)
	*(set_clock + 12) = 0;
    20f4:	d0a00717 	ldw	r2,-32740(gp)
    20f8:	10000305 	stb	zero,12(r2)
	if (!set_pressed) {
    20fc:	d0a01e43 	ldbu	r2,-32647(gp)
    2100:	10002e1e 	bne	r2,zero,21bc <btn_set_respond+0xd8>
		alt_putstr("Button set\n");
    2104:	01000034 	movhi	r4,0
static void btn_set_respond(void* context, alt_u32 id) {
    2108:	deffff04 	addi	sp,sp,-4
		alt_putstr("Button set\n");
    210c:	210b0f04 	addi	r4,r4,11324
static void btn_set_respond(void* context, alt_u32 id) {
    2110:	dfc00015 	stw	ra,0(sp)
		alt_putstr("Button set\n");
    2114:	0002b0c0 	call	2b0c <alt_putstr>
		if (irqtimer_stall) {
    2118:	d0e01f43 	ldbu	r3,-32643(gp)
		set_pressed = TRUE;
    211c:	00800044 	movi	r2,1
    2120:	d0a01e45 	stb	r2,-32647(gp)
		if (irqtimer_stall) {
    2124:	18001c26 	beq	r3,zero,2198 <btn_set_respond+0xb4>
			switch(time_unit_sel)
    2128:	d0a0008f 	ldh	r2,-32766(gp)
    212c:	10c000e0 	cmpeqi	r3,r2,3
    2130:	1800091e 	bne	r3,zero,2158 <btn_set_respond+0x74>
    2134:	10c00120 	cmpeqi	r3,r2,4
    2138:	1800091e 	bne	r3,zero,2160 <btn_set_respond+0x7c>
    213c:	10800098 	cmpnei	r2,r2,2
    2140:	1000021e 	bne	r2,zero,214c <btn_set_respond+0x68>
				time_unit_sel = MIN;
    2144:	008000c4 	movi	r2,3
				time_unit_sel = HR;
    2148:	d0a0008d 	sth	r2,-32766(gp)
}
    214c:	dfc00017 	ldw	ra,0(sp)
    2150:	dec00104 	addi	sp,sp,4
    2154:	f800283a 	ret
				time_unit_sel = HR;
    2158:	00800104 	movi	r2,4
    215c:	003ffa06 	br	2148 <btn_set_respond+0x64>
				time_unit_sel = SEC;
    2160:	00800084 	movi	r2,2
    2164:	d0a0008d 	sth	r2,-32766(gp)
				irqtimer_stall = FALSE;
    2168:	d0201f45 	stb	zero,-32643(gp)
  do { context = __builtin_rdctl(0); } while (0);
    216c:	0007303a 	rdctl	r3,status
  do { __builtin_wrctl(0, context & ~(0x00000001)); } while (0);
    2170:	00bfff84 	movi	r2,-2
    2174:	1884703a 	and	r2,r3,r2
    2178:	1001703a 	wrctl	status,r2
  alt_irq_active |= (1 << id);
    217c:	d0a02317 	ldw	r2,-32628(gp)
    2180:	10800414 	ori	r2,r2,16
  alt_irq_active &= ~(1 << id);
    2184:	d0a02315 	stw	r2,-32628(gp)
  do { __builtin_wrctl(3, alt_irq_active); } while (0);
    2188:	d0a02317 	ldw	r2,-32628(gp)
    218c:	100170fa 	wrctl	ienable,r2
	do { __builtin_wrctl(0, context); } while (0);
    2190:	1801703a 	wrctl	status,r3
  return 0;
    2194:	003fed06 	br	214c <btn_set_respond+0x68>
			irqtimer_stall = TRUE;
    2198:	d0a01f45 	stb	r2,-32643(gp)
  do { context = __builtin_rdctl(0); } while (0);
    219c:	0007303a 	rdctl	r3,status
  do { __builtin_wrctl(0, context & ~(0x00000001)); } while (0);
    21a0:	00bfff84 	movi	r2,-2
    21a4:	1884703a 	and	r2,r3,r2
    21a8:	1001703a 	wrctl	status,r2
  alt_irq_active &= ~(1 << id);
    21ac:	d0a02317 	ldw	r2,-32628(gp)
    21b0:	013ffbc4 	movi	r4,-17
    21b4:	1104703a 	and	r2,r2,r4
    21b8:	003ff206 	br	2184 <btn_set_respond+0xa0>
		alt_putstr("Button already set\n");
    21bc:	01000034 	movhi	r4,0
    21c0:	210b1204 	addi	r4,r4,11336
    21c4:	0002b0c1 	jmpi	2b0c <alt_putstr>

000021c8 <irq_handler>:
{
    21c8:	defffe04 	addi	sp,sp,-8
    21cc:	dfc00115 	stw	ra,4(sp)
    21d0:	dc000015 	stw	r16,0(sp)
  do { active = __builtin_rdctl(4); } while (0);
    21d4:	0007313a 	rdctl	r3,ipending
        alt_irq[i].handler(alt_irq[i].context, i);
    21d8:	04000034 	movhi	r16,0
    21dc:	840b4b04 	addi	r16,r16,11564
    i = 0;
    21e0:	000b883a 	mov	r5,zero
    mask = 1;
    21e4:	00800044 	movi	r2,1
      if (active & mask)
    21e8:	1888703a 	and	r4,r3,r2
    21ec:	20000b26 	beq	r4,zero,221c <irq_handler+0x54>
        alt_irq[i].handler(alt_irq[i].context, i);
    21f0:	280490fa 	slli	r2,r5,3
    21f4:	8085883a 	add	r2,r16,r2
    21f8:	10c00017 	ldw	r3,0(r2)
    21fc:	11000117 	ldw	r4,4(r2)
    2200:	183ee83a 	callr	r3
  do { active = __builtin_rdctl(4); } while (0);
    2204:	0007313a 	rdctl	r3,ipending
  } while (active);
    2208:	183ff51e 	bne	r3,zero,21e0 <irq_handler+0x18>
}
    220c:	dfc00117 	ldw	ra,4(sp)
    2210:	dc000017 	ldw	r16,0(sp)
    2214:	dec00204 	addi	sp,sp,8
    2218:	f800283a 	ret
      mask <<= 1;
    221c:	1004907a 	slli	r2,r2,1
      i++;
    2220:	29400044 	addi	r5,r5,1
      if (active & mask)
    2224:	003ff006 	br	21e8 <irq_handler+0x20>

00002228 <alt_irq_register>:
  if (id < ALT_NIRQ)
    2228:	20800828 	cmpgeui	r2,r4,32
    222c:	1000201e 	bne	r2,zero,22b0 <alt_irq_register+0x88>
  do { context = __builtin_rdctl(0); } while (0);
    2230:	000f303a 	rdctl	r7,status
  do { __builtin_wrctl(0, context & ~(0x00000001)); } while (0);
    2234:	00ffff84 	movi	r3,-2
    2238:	38c4703a 	and	r2,r7,r3
    223c:	1001703a 	wrctl	status,r2
    alt_irq[id].handler = handler;
    2240:	201090fa 	slli	r8,r4,3
    2244:	00800034 	movhi	r2,0
    2248:	108b4b04 	addi	r2,r2,11564
    224c:	1205883a 	add	r2,r2,r8
    2250:	11800015 	stw	r6,0(r2)
    alt_irq[id].context = context;
    2254:	11400115 	stw	r5,4(r2)
  alt_irq_active |= (1 << id);
    2258:	00800044 	movi	r2,1
    225c:	1108983a 	sll	r4,r2,r4
    rc = (handler) ? alt_irq_enable (id): alt_irq_disable (id);
    2260:	30000c26 	beq	r6,zero,2294 <alt_irq_register+0x6c>
  do { context = __builtin_rdctl(0); } while (0);
    2264:	0005303a 	rdctl	r2,status
  do { __builtin_wrctl(0, context & ~(0x00000001)); } while (0);
    2268:	10c6703a 	and	r3,r2,r3
    226c:	1801703a 	wrctl	status,r3
  alt_irq_active |= (1 << id);
    2270:	d0e02317 	ldw	r3,-32628(gp)
    2274:	20c8b03a 	or	r4,r4,r3
  alt_irq_active &= ~(1 << id);
    2278:	d1202315 	stw	r4,-32628(gp)
  do { __builtin_wrctl(3, alt_irq_active); } while (0);
    227c:	d0e02317 	ldw	r3,-32628(gp)
    2280:	180170fa 	wrctl	ienable,r3
	do { __builtin_wrctl(0, context); } while (0);
    2284:	1001703a 	wrctl	status,r2
    2288:	3801703a 	wrctl	status,r7
    rc = (handler) ? alt_irq_enable (id): alt_irq_disable (id);
    228c:	0005883a 	mov	r2,zero
}
    2290:	f800283a 	ret
  do { context = __builtin_rdctl(0); } while (0);
    2294:	0005303a 	rdctl	r2,status
  do { __builtin_wrctl(0, context & ~(0x00000001)); } while (0);
    2298:	10c6703a 	and	r3,r2,r3
    229c:	1801703a 	wrctl	status,r3
  alt_irq_active &= ~(1 << id);
    22a0:	d0e02317 	ldw	r3,-32628(gp)
    22a4:	0108303a 	nor	r4,zero,r4
    22a8:	20c8703a 	and	r4,r4,r3
    22ac:	003ff206 	br	2278 <alt_irq_register+0x50>
  int rc = -22;
    22b0:	00bffa84 	movi	r2,-22
}
    22b4:	f800283a 	ret

000022b8 <numberToSeg7>:
	alt_irq_register(BTN_DOWN_IRQ, BTN_DOWN_BASE, btn_down_respond);
}

void numberToSeg7(int num, volatile unsigned char* seg7) {

  switch (num) {
    22b8:	208002a8 	cmpgeui	r2,r4,10
    22bc:	1000111e 	bne	r2,zero,2304 <numberToSeg7+0x4c>
    22c0:	200890ba 	slli	r4,r4,2
    22c4:	00800034 	movhi	r2,0
    22c8:	2085883a 	add	r2,r4,r2
    22cc:	1088b517 	ldw	r2,8916(r2)
    22d0:	1000683a 	jmp	r2
    22d4:	000022fc 	xorhi	zero,zero,139
    22d8:	00002308 	cmpgei	zero,zero,140
    22dc:	00002310 	cmplti	zero,zero,140
    22e0:	00002318 	cmpnei	zero,zero,140
    22e4:	00002320 	cmpeqi	zero,zero,140
    22e8:	00002328 	cmpgeui	zero,zero,140
    22ec:	00002330 	cmpltui	zero,zero,140
    22f0:	00002338 	rdprs	zero,zero,140
    22f4:	00002340 	call	234 <__alt_mem_RAM-0x1dcc>
    22f8:	00002348 	cmpgei	zero,zero,141
    case 0:
      *seg7 = 0b1000000;
    22fc:	00801004 	movi	r2,64
    case 8:
      *seg7 = 0b0000000;
      break;

    case 9:
      *seg7 = 0b0011000;
    2300:	28800005 	stb	r2,0(r5)
      break;
  }

  return;

}
    2304:	f800283a 	ret
      *seg7 = 0b1111001;
    2308:	00801e44 	movi	r2,121
    230c:	003ffc06 	br	2300 <numberToSeg7+0x48>
      *seg7 = 0b0100100;
    2310:	00800904 	movi	r2,36
    2314:	003ffa06 	br	2300 <numberToSeg7+0x48>
      *seg7 = 0b0110000;
    2318:	00800c04 	movi	r2,48
    231c:	003ff806 	br	2300 <numberToSeg7+0x48>
      *seg7 = 0b0011001;
    2320:	00800644 	movi	r2,25
    2324:	003ff606 	br	2300 <numberToSeg7+0x48>
      *seg7 = 0b0010010;
    2328:	00800484 	movi	r2,18
    232c:	003ff406 	br	2300 <numberToSeg7+0x48>
      *seg7 = 0b0000010;
    2330:	00800084 	movi	r2,2
    2334:	003ff206 	br	2300 <numberToSeg7+0x48>
      *seg7 = 0b1111000;
    2338:	00801e04 	movi	r2,120
    233c:	003ff006 	br	2300 <numberToSeg7+0x48>
      *seg7 = 0b0000000;
    2340:	28000005 	stb	zero,0(r5)
      break;
    2344:	f800283a 	ret
      *seg7 = 0b0011000;
    2348:	00800604 	movi	r2,24
    234c:	003fec06 	br	2300 <numberToSeg7+0x48>

00002350 <set_value>:

/**
 * Set values to the correct output.
 */
int set_value(unsigned short value, volatile unsigned char* seg1, volatile unsigned char* seg0)
{
    2350:	defffc04 	addi	sp,sp,-16
    2354:	dc000015 	stw	r16,0(sp)
	//*seg1 = (unsigned char) value / 10;
	//*seg0 = (unsigned char) value % 10;

	numberToSeg7(value / 10, seg1);
    2358:	243fffcc 	andi	r16,r4,65535
{
    235c:	dc800215 	stw	r18,8(sp)
	numberToSeg7(value / 10, seg1);
    2360:	8009883a 	mov	r4,r16
{
    2364:	2825883a 	mov	r18,r5
	numberToSeg7(value / 10, seg1);
    2368:	01400284 	movi	r5,10
{
    236c:	dfc00315 	stw	ra,12(sp)
    2370:	dc400115 	stw	r17,4(sp)
    2374:	3023883a 	mov	r17,r6
	numberToSeg7(value / 10, seg1);
    2378:	00028100 	call	2810 <__udivsi3>
    237c:	900b883a 	mov	r5,r18
    2380:	113fffcc 	andi	r4,r2,65535
    2384:	00022b80 	call	22b8 <numberToSeg7>
	numberToSeg7(value % 10, seg0);
    2388:	8009883a 	mov	r4,r16
    238c:	01400284 	movi	r5,10
    2390:	00028740 	call	2874 <__umodsi3>
    2394:	113fffcc 	andi	r4,r2,65535
    2398:	880b883a 	mov	r5,r17
    239c:	00022b80 	call	22b8 <numberToSeg7>

	return 0;
}
    23a0:	0005883a 	mov	r2,zero
    23a4:	dfc00317 	ldw	ra,12(sp)
    23a8:	dc800217 	ldw	r18,8(sp)
    23ac:	dc400117 	ldw	r17,4(sp)
    23b0:	dc000017 	ldw	r16,0(sp)
    23b4:	dec00404 	addi	sp,sp,16
    23b8:	f800283a 	ret

000023bc <add_second>:
 */
void add_second()
{
//	if (sel == 0) {
	// Add a second
	hour[0]++;
    23bc:	d0a0200b 	ldhu	r2,-32640(gp)
    23c0:	10800044 	addi	r2,r2,1

	if (hour[0] == 60)
    23c4:	10ffffcc 	andi	r3,r2,65535
    23c8:	18c00f20 	cmpeqi	r3,r3,60
    23cc:	1800021e 	bne	r3,zero,23d8 <add_second+0x1c>
	hour[0]++;
    23d0:	d0a0200d 	sth	r2,-32640(gp)
    23d4:	f800283a 	ret
	{
		hour[0] = 0;
		hour[1]++;
    23d8:	d0a0208b 	ldhu	r2,-32638(gp)
		hour[0] = 0;
    23dc:	d020200d 	sth	zero,-32640(gp)
		hour[1]++;
    23e0:	10800044 	addi	r2,r2,1

		if (hour[1] == 60)
    23e4:	10ffffcc 	andi	r3,r2,65535
    23e8:	18c00f20 	cmpeqi	r3,r3,60
    23ec:	1800021e 	bne	r3,zero,23f8 <add_second+0x3c>
		hour[1]++;
    23f0:	d0a0208d 	sth	r2,-32638(gp)
    23f4:	f800283a 	ret
		{
			hour[1] = 0;
			hour[2]++;
    23f8:	d0a0210b 	ldhu	r2,-32636(gp)
			hour[1] = 0;
    23fc:	d020208d 	sth	zero,-32638(gp)
			hour[2]++;
    2400:	10800044 	addi	r2,r2,1

			if (hour[2] == 24)
    2404:	10ffffcc 	andi	r3,r2,65535
    2408:	18c00620 	cmpeqi	r3,r3,24
    240c:	1800021e 	bne	r3,zero,2418 <add_second+0x5c>
			hour[2]++;
    2410:	d0a0210d 	sth	r2,-32636(gp)
    2414:	f800283a 	ret
			{
				hour[2] = 0;
    2418:	d020210d 	sth	zero,-32636(gp)
			}
		}
	}
}
    241c:	f800283a 	ret

00002420 <display_hour>:

void display_hour()
{
	alt_printf("%x %x : %x %x : %x %x\n", *h1_ptr, *h0_ptr, *m1_ptr, *m0_ptr,
    2420:	d0a00d17 	ldw	r2,-32716(gp)
{
    2424:	defffc04 	addi	sp,sp,-16
    2428:	dfc00315 	stw	ra,12(sp)
	alt_printf("%x %x : %x %x : %x %x\n", *h1_ptr, *h0_ptr, *m1_ptr, *m0_ptr,
    242c:	11400003 	ldbu	r5,0(r2)
    2430:	d0a00c17 	ldw	r2,-32720(gp)
									   *s1_ptr, *s0_ptr);
    2434:	d0e00917 	ldw	r3,-32732(gp)
    2438:	d1200817 	ldw	r4,-32736(gp)
	alt_printf("%x %x : %x %x : %x %x\n", *h1_ptr, *h0_ptr, *m1_ptr, *m0_ptr,
    243c:	11800003 	ldbu	r6,0(r2)
    2440:	d0a00b17 	ldw	r2,-32724(gp)
    2444:	29403fcc 	andi	r5,r5,255
    2448:	31803fcc 	andi	r6,r6,255
    244c:	11c00003 	ldbu	r7,0(r2)
    2450:	d0a00a17 	ldw	r2,-32728(gp)
    2454:	39c03fcc 	andi	r7,r7,255
    2458:	10800003 	ldbu	r2,0(r2)
									   *s1_ptr, *s0_ptr);
    245c:	18c00003 	ldbu	r3,0(r3)
    2460:	21000003 	ldbu	r4,0(r4)
	alt_printf("%x %x : %x %x : %x %x\n", *h1_ptr, *h0_ptr, *m1_ptr, *m0_ptr,
    2464:	10803fcc 	andi	r2,r2,255
    2468:	18c03fcc 	andi	r3,r3,255
    246c:	21003fcc 	andi	r4,r4,255
    2470:	d9000215 	stw	r4,8(sp)
    2474:	01000034 	movhi	r4,0
    2478:	d8c00115 	stw	r3,4(sp)
    247c:	d8800015 	stw	r2,0(sp)
    2480:	210b1704 	addi	r4,r4,11356
    2484:	00029800 	call	2980 <alt_printf>
}
    2488:	dfc00317 	ldw	ra,12(sp)
    248c:	dec00404 	addi	sp,sp,16
    2490:	f800283a 	ret

00002494 <timer_respond>:

/**
 * Handler for timer interrupt.
 */
static void timer_respond(void* context){
    2494:	deffff04 	addi	sp,sp,-4
    2498:	dfc00015 	stw	ra,0(sp)

	set_pressed = FALSE;
    249c:	d0201e45 	stb	zero,-32647(gp)
	ud_buttons_en = FALSE;
    24a0:	d0201f05 	stb	zero,-32644(gp)
  do { context = __builtin_rdctl(0); } while (0);
    24a4:	0009303a 	rdctl	r4,status
  do { __builtin_wrctl(0, context & ~(0x00000001)); } while (0);
    24a8:	00bfff84 	movi	r2,-2
    24ac:	2086703a 	and	r3,r4,r2
    24b0:	1801703a 	wrctl	status,r3
  alt_irq_active &= ~(1 << id);
    24b4:	d0e02317 	ldw	r3,-32628(gp)
    24b8:	017ffec4 	movi	r5,-5
    24bc:	1946703a 	and	r3,r3,r5
    24c0:	d0e02315 	stw	r3,-32628(gp)
  do { __builtin_wrctl(3, alt_irq_active); } while (0);
    24c4:	d0e02317 	ldw	r3,-32628(gp)
    24c8:	180170fa 	wrctl	ienable,r3
	do { __builtin_wrctl(0, context); } while (0);
    24cc:	2001703a 	wrctl	status,r4
  do { context = __builtin_rdctl(0); } while (0);
    24d0:	0007303a 	rdctl	r3,status
  do { __builtin_wrctl(0, context & ~(0x00000001)); } while (0);
    24d4:	1884703a 	and	r2,r3,r2
    24d8:	1001703a 	wrctl	status,r2
  alt_irq_active &= ~(1 << id);
    24dc:	d0a02317 	ldw	r2,-32628(gp)
    24e0:	013ffdc4 	movi	r4,-9
    24e4:	1104703a 	and	r2,r2,r4
    24e8:	d0a02315 	stw	r2,-32628(gp)
  do { __builtin_wrctl(3, alt_irq_active); } while (0);
    24ec:	d0a02317 	ldw	r2,-32628(gp)
    24f0:	100170fa 	wrctl	ienable,r2
	do { __builtin_wrctl(0, context); } while (0);
    24f4:	1801703a 	wrctl	status,r3

	alt_irq_disable(BTN_UP_IRQ);
	alt_irq_disable(BTN_DOWN_IRQ);

	/* Acknowledge interrupt by clearing status register */
	*timer_base_ptr = 0x0;
    24f8:	d0a00117 	ldw	r2,-32764(gp)
    24fc:	10000005 	stb	zero,0(r2)

	add_second();
    2500:	00023bc0 	call	23bc <add_second>

	if (*swc_alarm == 1 && hour[2] == alarm [2] &&
    2504:	d0a00317 	ldw	r2,-32756(gp)
    2508:	10800003 	ldbu	r2,0(r2)
    250c:	10803fcc 	andi	r2,r2,255
    2510:	10c00058 	cmpnei	r3,r2,1
    2514:	18001a1e 	bne	r3,zero,2580 <timer_respond+0xec>
    2518:	d120210b 	ldhu	r4,-32636(gp)
    251c:	d0e0228b 	ldhu	r3,-32630(gp)
    2520:	20c0171e 	bne	r4,r3,2580 <timer_respond+0xec>
    2524:	d120208b 	ldhu	r4,-32638(gp)
    2528:	d0e0220b 	ldhu	r3,-32632(gp)
    252c:	20c0141e 	bne	r4,r3,2580 <timer_respond+0xec>
			hour[1] == alarm[1] && hour[0] < 30) {
    2530:	d0e0200b 	ldhu	r3,-32640(gp)
    2534:	18c007a8 	cmpgeui	r3,r3,30
    2538:	1800111e 	bne	r3,zero,2580 <timer_respond+0xec>
		*alarm_ptr = (unsigned char) 1;
    253c:	d0e00217 	ldw	r3,-32760(gp)
    2540:	18800005 	stb	r2,0(r3)
	} else {
		*alarm_ptr = (unsigned char) 0;
	}

	set_value(hour[0], s1_ptr, s0_ptr);
    2544:	d1a00817 	ldw	r6,-32736(gp)
    2548:	d1600917 	ldw	r5,-32732(gp)
    254c:	d120200b 	ldhu	r4,-32640(gp)
    2550:	00023500 	call	2350 <set_value>
	set_value(hour[1], m1_ptr, m0_ptr);
    2554:	d1a00a17 	ldw	r6,-32728(gp)
    2558:	d1600b17 	ldw	r5,-32724(gp)
    255c:	d120208b 	ldhu	r4,-32638(gp)
    2560:	00023500 	call	2350 <set_value>
	set_value(hour[2], h1_ptr, h0_ptr);
    2564:	d1a00c17 	ldw	r6,-32720(gp)
    2568:	d1600d17 	ldw	r5,-32716(gp)
    256c:	d120210b 	ldhu	r4,-32636(gp)
    2570:	00023500 	call	2350 <set_value>

	display_hour();
}
    2574:	dfc00017 	ldw	ra,0(sp)
    2578:	dec00104 	addi	sp,sp,4
	display_hour();
    257c:	00024201 	jmpi	2420 <display_hour>
		*alarm_ptr = (unsigned char) 0;
    2580:	d0a00217 	ldw	r2,-32760(gp)
    2584:	10000005 	stb	zero,0(r2)
    2588:	003fee06 	br	2544 <timer_respond+0xb0>

0000258c <init_values>:
/**
 * Initialize the pointers to zero to avoid unexpected behaviour at the beggining
 */
void init_values(){
	// init all the pointers to zero
	*h1_ptr = 0;
    258c:	d0a00d17 	ldw	r2,-32716(gp)
    2590:	10000005 	stb	zero,0(r2)
	*h0_ptr = 0;
    2594:	d0a00c17 	ldw	r2,-32720(gp)
    2598:	10000005 	stb	zero,0(r2)
	*m1_ptr = 0;
    259c:	d0a00b17 	ldw	r2,-32724(gp)
    25a0:	10000005 	stb	zero,0(r2)
	*m0_ptr = 0;
    25a4:	d0a00a17 	ldw	r2,-32728(gp)
    25a8:	10000005 	stb	zero,0(r2)
	*s1_ptr = 0;
    25ac:	d0a00917 	ldw	r2,-32732(gp)
    25b0:	10000005 	stb	zero,0(r2)
	*s0_ptr = 0;
    25b4:	d0a00817 	ldw	r2,-32736(gp)
    25b8:	10000005 	stb	zero,0(r2)

	// alarm sound set to zero
	*alarm_ptr = 0;
    25bc:	d0a00217 	ldw	r2,-32760(gp)
    25c0:	10000005 	stb	zero,0(r2)
}
    25c4:	f800283a 	ret

000025c8 <main>:

int main()
{ 
	alt_putstr("Welcome to the Alarm Clock\n");
    25c8:	01000034 	movhi	r4,0
{ 
    25cc:	defffc04 	addi	sp,sp,-16
	alt_putstr("Welcome to the Alarm Clock\n");
    25d0:	210b1d04 	addi	r4,r4,11380
{ 
    25d4:	dfc00315 	stw	ra,12(sp)
    25d8:	dc800215 	stw	r18,8(sp)
    25dc:	dc400115 	stw	r17,4(sp)
    25e0:	dc000015 	stw	r16,0(sp)
	alt_putstr("Welcome to the Alarm Clock\n");
    25e4:	0002b0c0 	call	2b0c <alt_putstr>

	if (first) {
    25e8:	d0a00003 	ldbu	r2,-32768(gp)
    25ec:	10000226 	beq	r2,zero,25f8 <main+0x30>
		init_values();
    25f0:	000258c0 	call	258c <init_values>
		first = FALSE;
    25f4:	d0200005 	stb	zero,-32768(gp)
	*(set_clock + 8) = 0x1;
    25f8:	d0a00717 	ldw	r2,-32740(gp)
    25fc:	04000044 	movi	r16,1
	alt_irq_register(BTN_SET_IRQ, BTN_SET_BASE, btn_set_respond);
    2600:	01800034 	movhi	r6,0
	*(set_clock + 8) = 0x1;
    2604:	14000205 	stb	r16,8(r2)
	alt_irq_register(BTN_SET_IRQ, BTN_SET_BASE, btn_set_respond);
    2608:	31883904 	addi	r6,r6,8420
    260c:	01541804 	movi	r5,20576
    2610:	01000044 	movi	r4,1
	*(set_clock + 12) = 0x0;
    2614:	10000305 	stb	zero,12(r2)
	alt_irq_register(BTN_SET_IRQ, BTN_SET_BASE, btn_set_respond);
    2618:	00022280 	call	2228 <alt_irq_register>
	*(up_ptr + 8) = 0x1;
    261c:	d0a00617 	ldw	r2,-32744(gp)
	alt_irq_register(BTN_UP_IRQ, BTN_UP_BASE, btn_up_respond);
    2620:	01800034 	movhi	r6,0
    2624:	31882804 	addi	r6,r6,8352
	*(up_ptr + 8) = 0x1;
    2628:	14000205 	stb	r16,8(r2)
	alt_irq_register(BTN_UP_IRQ, BTN_UP_BASE, btn_up_respond);
    262c:	01541404 	movi	r5,20560
    2630:	01000084 	movi	r4,2
	*(up_ptr + 12) = 0x0;
    2634:	10000305 	stb	zero,12(r2)
	alt_irq_register(BTN_UP_IRQ, BTN_UP_BASE, btn_up_respond);
    2638:	00022280 	call	2228 <alt_irq_register>
	*(down_ptr + 8) = 0x1;
    263c:	d0a00517 	ldw	r2,-32748(gp)
	alt_irq_register(BTN_DOWN_IRQ, BTN_DOWN_BASE, btn_down_respond);
    2640:	01800034 	movhi	r6,0
    2644:	31881704 	addi	r6,r6,8284
	*(down_ptr + 8) = 0x1;
    2648:	14000205 	stb	r16,8(r2)
	alt_irq_register(BTN_DOWN_IRQ, BTN_DOWN_BASE, btn_down_respond);
    264c:	01541004 	movi	r5,20544
    2650:	010000c4 	movi	r4,3
	*(down_ptr + 12) = 0x0;
    2654:	10000305 	stb	zero,12(r2)
	alt_irq_register(BTN_DOWN_IRQ, BTN_DOWN_BASE, btn_down_respond);
    2658:	00022280 	call	2228 <alt_irq_register>
  do { context = __builtin_rdctl(0); } while (0);
    265c:	0009303a 	rdctl	r4,status
  do { __builtin_wrctl(0, context & ~(0x00000001)); } while (0);
    2660:	00bfff84 	movi	r2,-2
    2664:	2086703a 	and	r3,r4,r2
    2668:	1801703a 	wrctl	status,r3
  alt_irq_active &= ~(1 << id);
    266c:	d0e02317 	ldw	r3,-32628(gp)
    2670:	017ffec4 	movi	r5,-5
    2674:	1946703a 	and	r3,r3,r5
    2678:	d0e02315 	stw	r3,-32628(gp)
  do { __builtin_wrctl(3, alt_irq_active); } while (0);
    267c:	d0e02317 	ldw	r3,-32628(gp)
    2680:	180170fa 	wrctl	ienable,r3
	do { __builtin_wrctl(0, context); } while (0);
    2684:	2001703a 	wrctl	status,r4
  do { context = __builtin_rdctl(0); } while (0);
    2688:	0007303a 	rdctl	r3,status
  do { __builtin_wrctl(0, context & ~(0x00000001)); } while (0);
    268c:	1884703a 	and	r2,r3,r2
    2690:	1001703a 	wrctl	status,r2
  alt_irq_active &= ~(1 << id);
    2694:	d0a02317 	ldw	r2,-32628(gp)
    2698:	013ffdc4 	movi	r4,-9
    269c:	1104703a 	and	r2,r2,r4
    26a0:	d0a02315 	stw	r2,-32628(gp)
  do { __builtin_wrctl(3, alt_irq_active); } while (0);
    26a4:	d0a02317 	ldw	r2,-32628(gp)
    26a8:	100170fa 	wrctl	ienable,r2
	do { __builtin_wrctl(0, context); } while (0);
    26ac:	1801703a 	wrctl	status,r3
	*(timer_base_ptr + 4) = 0x1 | 0x4;
    26b0:	d0a00117 	ldw	r2,-32764(gp)
    26b4:	00c00144 	movi	r3,5
	alt_irq_register(TIMER_IRQ, TIMER_BASE /*timer_base_ptr*/, timer_respond);
    26b8:	01800034 	movhi	r6,0
	*(timer_base_ptr + 4) = 0x1 | 0x4;
    26bc:	10c00105 	stb	r3,4(r2)
	alt_irq_register(TIMER_IRQ, TIMER_BASE /*timer_base_ptr*/, timer_respond);
    26c0:	31892504 	addi	r6,r6,9364
    26c4:	01540004 	movi	r5,20480
    26c8:	01000104 	movi	r4,4
    26cc:	00022280 	call	2228 <alt_irq_register>
	timer_init();

	while (1)
	{

		hour[0]= 10;
    26d0:	04800284 	movi	r18,10
		hour[1]=15;
    26d4:	044003c4 	movi	r17,15
		hour[2]=20;
    26d8:	04000504 	movi	r16,20
		set_value(hour[0], s1_ptr, s0_ptr);
    26dc:	d1a00817 	ldw	r6,-32736(gp)
    26e0:	d1600917 	ldw	r5,-32732(gp)
    26e4:	01000284 	movi	r4,10
		hour[0]= 10;
    26e8:	d4a0200d 	sth	r18,-32640(gp)
		hour[1]=15;
    26ec:	d460208d 	sth	r17,-32638(gp)
		hour[2]=20;
    26f0:	d420210d 	sth	r16,-32636(gp)
		set_value(hour[0], s1_ptr, s0_ptr);
    26f4:	00023500 	call	2350 <set_value>
		set_value(hour[1], m1_ptr, m0_ptr);
    26f8:	d1a00a17 	ldw	r6,-32728(gp)
    26fc:	d1600b17 	ldw	r5,-32724(gp)
    2700:	d120208b 	ldhu	r4,-32638(gp)
    2704:	00023500 	call	2350 <set_value>
		set_value(hour[2], h1_ptr, h0_ptr);
    2708:	d1a00c17 	ldw	r6,-32720(gp)
    270c:	d1600d17 	ldw	r5,-32716(gp)
    2710:	d120210b 	ldhu	r4,-32636(gp)
    2714:	00023500 	call	2350 <set_value>
	while (1)
    2718:	003ff006 	br	26dc <main+0x114>

0000271c <__divsi3>:
    271c:	20001a16 	blt	r4,zero,2788 <__divsi3+0x6c>
    2720:	000f883a 	mov	r7,zero
    2724:	2800020e 	bge	r5,zero,2730 <__divsi3+0x14>
    2728:	014bc83a 	sub	r5,zero,r5
    272c:	39c0005c 	xori	r7,r7,1
    2730:	200d883a 	mov	r6,r4
    2734:	00c00044 	movi	r3,1
    2738:	2900092e 	bgeu	r5,r4,2760 <__divsi3+0x44>
    273c:	00800804 	movi	r2,32
    2740:	00c00044 	movi	r3,1
    2744:	00000106 	br	274c <__divsi3+0x30>
    2748:	10001226 	beq	r2,zero,2794 <__divsi3+0x78>
    274c:	294b883a 	add	r5,r5,r5
    2750:	10bfffc4 	addi	r2,r2,-1
    2754:	18c7883a 	add	r3,r3,r3
    2758:	293ffb36 	bltu	r5,r4,2748 <__divsi3+0x2c>
    275c:	18000d26 	beq	r3,zero,2794 <__divsi3+0x78>
    2760:	0005883a 	mov	r2,zero
    2764:	31400236 	bltu	r6,r5,2770 <__divsi3+0x54>
    2768:	314dc83a 	sub	r6,r6,r5
    276c:	10c4b03a 	or	r2,r2,r3
    2770:	1806d07a 	srli	r3,r3,1
    2774:	280ad07a 	srli	r5,r5,1
    2778:	183ffa1e 	bne	r3,zero,2764 <__divsi3+0x48>
    277c:	38000126 	beq	r7,zero,2784 <__divsi3+0x68>
    2780:	0085c83a 	sub	r2,zero,r2
    2784:	f800283a 	ret
    2788:	0109c83a 	sub	r4,zero,r4
    278c:	01c00044 	movi	r7,1
    2790:	003fe406 	br	2724 <__divsi3+0x8>
    2794:	0005883a 	mov	r2,zero
    2798:	003ff806 	br	277c <__divsi3+0x60>

0000279c <__modsi3>:
    279c:	20001916 	blt	r4,zero,2804 <__modsi3+0x68>
    27a0:	000f883a 	mov	r7,zero
    27a4:	2005883a 	mov	r2,r4
    27a8:	2800010e 	bge	r5,zero,27b0 <__modsi3+0x14>
    27ac:	014bc83a 	sub	r5,zero,r5
    27b0:	00c00044 	movi	r3,1
    27b4:	2900092e 	bgeu	r5,r4,27dc <__modsi3+0x40>
    27b8:	01800804 	movi	r6,32
    27bc:	00c00044 	movi	r3,1
    27c0:	00000106 	br	27c8 <__modsi3+0x2c>
    27c4:	30000d26 	beq	r6,zero,27fc <__modsi3+0x60>
    27c8:	294b883a 	add	r5,r5,r5
    27cc:	31bfffc4 	addi	r6,r6,-1
    27d0:	18c7883a 	add	r3,r3,r3
    27d4:	293ffb36 	bltu	r5,r4,27c4 <__modsi3+0x28>
    27d8:	18000826 	beq	r3,zero,27fc <__modsi3+0x60>
    27dc:	1806d07a 	srli	r3,r3,1
    27e0:	11400136 	bltu	r2,r5,27e8 <__modsi3+0x4c>
    27e4:	1145c83a 	sub	r2,r2,r5
    27e8:	280ad07a 	srli	r5,r5,1
    27ec:	183ffb1e 	bne	r3,zero,27dc <__modsi3+0x40>
    27f0:	38000126 	beq	r7,zero,27f8 <__modsi3+0x5c>
    27f4:	0085c83a 	sub	r2,zero,r2
    27f8:	f800283a 	ret
    27fc:	2005883a 	mov	r2,r4
    2800:	003ffb06 	br	27f0 <__modsi3+0x54>
    2804:	0109c83a 	sub	r4,zero,r4
    2808:	01c00044 	movi	r7,1
    280c:	003fe506 	br	27a4 <__modsi3+0x8>

00002810 <__udivsi3>:
    2810:	200d883a 	mov	r6,r4
    2814:	2900152e 	bgeu	r5,r4,286c <__udivsi3+0x5c>
    2818:	28001416 	blt	r5,zero,286c <__udivsi3+0x5c>
    281c:	00800804 	movi	r2,32
    2820:	00c00044 	movi	r3,1
    2824:	00000206 	br	2830 <__udivsi3+0x20>
    2828:	10000e26 	beq	r2,zero,2864 <__udivsi3+0x54>
    282c:	28000516 	blt	r5,zero,2844 <__udivsi3+0x34>
    2830:	294b883a 	add	r5,r5,r5
    2834:	10bfffc4 	addi	r2,r2,-1
    2838:	18c7883a 	add	r3,r3,r3
    283c:	293ffa36 	bltu	r5,r4,2828 <__udivsi3+0x18>
    2840:	18000826 	beq	r3,zero,2864 <__udivsi3+0x54>
    2844:	0005883a 	mov	r2,zero
    2848:	31400236 	bltu	r6,r5,2854 <__udivsi3+0x44>
    284c:	314dc83a 	sub	r6,r6,r5
    2850:	10c4b03a 	or	r2,r2,r3
    2854:	1806d07a 	srli	r3,r3,1
    2858:	280ad07a 	srli	r5,r5,1
    285c:	183ffa1e 	bne	r3,zero,2848 <__udivsi3+0x38>
    2860:	f800283a 	ret
    2864:	0005883a 	mov	r2,zero
    2868:	f800283a 	ret
    286c:	00c00044 	movi	r3,1
    2870:	003ff406 	br	2844 <__udivsi3+0x34>

00002874 <__umodsi3>:
    2874:	2005883a 	mov	r2,r4
    2878:	2900132e 	bgeu	r5,r4,28c8 <__umodsi3+0x54>
    287c:	28001216 	blt	r5,zero,28c8 <__umodsi3+0x54>
    2880:	01800804 	movi	r6,32
    2884:	00c00044 	movi	r3,1
    2888:	00000206 	br	2894 <__umodsi3+0x20>
    288c:	30000c26 	beq	r6,zero,28c0 <__umodsi3+0x4c>
    2890:	28000516 	blt	r5,zero,28a8 <__umodsi3+0x34>
    2894:	294b883a 	add	r5,r5,r5
    2898:	31bfffc4 	addi	r6,r6,-1
    289c:	18c7883a 	add	r3,r3,r3
    28a0:	293ffa36 	bltu	r5,r4,288c <__umodsi3+0x18>
    28a4:	18000626 	beq	r3,zero,28c0 <__umodsi3+0x4c>
    28a8:	1806d07a 	srli	r3,r3,1
    28ac:	11400136 	bltu	r2,r5,28b4 <__umodsi3+0x40>
    28b0:	1145c83a 	sub	r2,r2,r5
    28b4:	280ad07a 	srli	r5,r5,1
    28b8:	183ffb1e 	bne	r3,zero,28a8 <__umodsi3+0x34>
    28bc:	f800283a 	ret
    28c0:	2005883a 	mov	r2,r4
    28c4:	f800283a 	ret
    28c8:	00c00044 	movi	r3,1
    28cc:	003ff606 	br	28a8 <__umodsi3+0x34>

000028d0 <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
    28d0:	deffff04 	addi	sp,sp,-4

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
    28d4:	01000034 	movhi	r4,0
    28d8:	01400034 	movhi	r5,0
    28dc:	dfc00015 	stw	ra,0(sp)
    28e0:	210b2404 	addi	r4,r4,11408
    28e4:	294b3304 	addi	r5,r5,11468
    28e8:	21400426 	beq	r4,r5,28fc <alt_load+0x2c>
  {
    while( to != end )
    {
      *to++ = *from++;
    28ec:	01800034 	movhi	r6,0
    28f0:	318b3304 	addi	r6,r6,11468
    28f4:	310dc83a 	sub	r6,r6,r4
    28f8:	0002ba80 	call	2ba8 <memcpy>
  if (to != from)
    28fc:	01000034 	movhi	r4,0
    2900:	01400034 	movhi	r5,0
    2904:	21080804 	addi	r4,r4,8224
    2908:	29480804 	addi	r5,r5,8224
    290c:	21400426 	beq	r4,r5,2920 <alt_load+0x50>
      *to++ = *from++;
    2910:	01800034 	movhi	r6,0
    2914:	31880804 	addi	r6,r6,8224
    2918:	310dc83a 	sub	r6,r6,r4
    291c:	0002ba80 	call	2ba8 <memcpy>
  if (to != from)
    2920:	01000034 	movhi	r4,0
    2924:	01400034 	movhi	r5,0
    2928:	210afb04 	addi	r4,r4,11244
    292c:	294afb04 	addi	r5,r5,11244
    2930:	21400426 	beq	r4,r5,2944 <alt_load+0x74>
      *to++ = *from++;
    2934:	01800034 	movhi	r6,0
    2938:	318b2404 	addi	r6,r6,11408
    293c:	310dc83a 	sub	r6,r6,r4
    2940:	0002ba80 	call	2ba8 <memcpy>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
    2944:	0002b980 	call	2b98 <alt_dcache_flush_all>
  alt_icache_flush_all();
}
    2948:	dfc00017 	ldw	ra,0(sp)
    294c:	dec00104 	addi	sp,sp,4
  alt_icache_flush_all();
    2950:	0002b9c1 	jmpi	2b9c <alt_icache_flush_all>

00002954 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
    2954:	deffff04 	addi	sp,sp,-4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
    2958:	0009883a 	mov	r4,zero
{
    295c:	dfc00015 	stw	ra,0(sp)
  alt_irq_init (NULL);
    2960:	0002b440 	call	2b44 <alt_irq_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
    2964:	0002b640 	call	2b64 <alt_sys_init>
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
    2968:	d1a02417 	ldw	r6,-32624(gp)
    296c:	d1602517 	ldw	r5,-32620(gp)
    2970:	d1202617 	ldw	r4,-32616(gp)
  close(STDOUT_FILENO);
  exit (result);
#endif

  ALT_LOG_PRINT_BOOT("[alt_main.c] After main - we should not be here?.\r\n");
}
    2974:	dfc00017 	ldw	ra,0(sp)
    2978:	dec00104 	addi	sp,sp,4
  main (alt_argc, alt_argv, alt_envp);
    297c:	00025c81 	jmpi	25c8 <main>

00002980 <alt_printf>:
/* 
 * ALT printf function 
 */
void 
alt_printf(const char* fmt, ... )
{
    2980:	defff704 	addi	sp,sp,-36
    2984:	2005883a 	mov	r2,r4
    2988:	dfc00515 	stw	ra,20(sp)
    298c:	dd000415 	stw	r20,16(sp)
    2990:	dcc00315 	stw	r19,12(sp)
    2994:	dc800215 	stw	r18,8(sp)
    2998:	dc400115 	stw	r17,4(sp)
    299c:	dc000015 	stw	r16,0(sp)
    29a0:	d9400615 	stw	r5,24(sp)
    29a4:	d9800715 	stw	r6,28(sp)
    29a8:	d9c00815 	stw	r7,32(sp)
                        continue;
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
    29ac:	048003c4 	movi	r18,15
	va_start(args, fmt);
    29b0:	dc000604 	addi	r16,sp,24
    while ((c = *w++) != 0)
    29b4:	11000007 	ldb	r4,0(r2)
    29b8:	2000081e 	bne	r4,zero,29dc <alt_printf+0x5c>
        }
    }
#ifdef ALT_SEMIHOSTING
    alt_putbufflush();
#endif
}
    29bc:	dfc00517 	ldw	ra,20(sp)
    29c0:	dd000417 	ldw	r20,16(sp)
    29c4:	dcc00317 	ldw	r19,12(sp)
    29c8:	dc800217 	ldw	r18,8(sp)
    29cc:	dc400117 	ldw	r17,4(sp)
    29d0:	dc000017 	ldw	r16,0(sp)
    29d4:	dec00904 	addi	sp,sp,36
    29d8:	f800283a 	ret
        if (c != '%')
    29dc:	20c00960 	cmpeqi	r3,r4,37
    29e0:	1800031e 	bne	r3,zero,29f0 <alt_printf+0x70>
    while ((c = *w++) != 0)
    29e4:	14c00044 	addi	r19,r2,1
                        alt_putchar('0');
    29e8:	0002ac00 	call	2ac0 <alt_putchar>
                        continue;
    29ec:	00000d06 	br	2a24 <alt_printf+0xa4>
            if ((c = *w++) != 0)
    29f0:	14c00084 	addi	r19,r2,2
    29f4:	10800047 	ldb	r2,1(r2)
    29f8:	103ff026 	beq	r2,zero,29bc <alt_printf+0x3c>
                if (c == '%')
    29fc:	10c00958 	cmpnei	r3,r2,37
    2a00:	1800021e 	bne	r3,zero,2a0c <alt_printf+0x8c>
                    alt_putchar(c);
    2a04:	01000944 	movi	r4,37
    2a08:	003ff706 	br	29e8 <alt_printf+0x68>
                else if (c == 'c')
    2a0c:	10c018d8 	cmpnei	r3,r2,99
    2a10:	1800061e 	bne	r3,zero,2a2c <alt_printf+0xac>
                    alt_putchar(v);
    2a14:	81000017 	ldw	r4,0(r16)
                    int v = va_arg(args, int);
    2a18:	84400104 	addi	r17,r16,4
    2a1c:	8821883a 	mov	r16,r17
                    alt_putchar(v);
    2a20:	0002ac00 	call	2ac0 <alt_putchar>
                    int v = va_arg(args, int);
    2a24:	9805883a 	mov	r2,r19
    2a28:	003fe206 	br	29b4 <alt_printf+0x34>
                else if (c == 'x')
    2a2c:	10c01e18 	cmpnei	r3,r2,120
    2a30:	18001a1e 	bne	r3,zero,2a9c <alt_printf+0x11c>
                    unsigned long v = va_arg(args, unsigned long);
    2a34:	85000017 	ldw	r20,0(r16)
    2a38:	84000104 	addi	r16,r16,4
                    if (v == 0)
    2a3c:	a000131e 	bne	r20,zero,2a8c <alt_printf+0x10c>
                        alt_putchar('0');
    2a40:	01000c04 	movi	r4,48
    2a44:	003fe806 	br	29e8 <alt_printf+0x68>
                        digit_shift -= 4;
    2a48:	8c7fff04 	addi	r17,r17,-4
                    while (!(v & (0xF << digit_shift)))
    2a4c:	9444983a 	sll	r2,r18,r17
    2a50:	1504703a 	and	r2,r2,r20
    2a54:	103ffc26 	beq	r2,zero,2a48 <alt_printf+0xc8>
                    for (; digit_shift >= 0; digit_shift -= 4)
    2a58:	883ff216 	blt	r17,zero,2a24 <alt_printf+0xa4>
                        digit = (v & (0xF << digit_shift)) >> digit_shift;
    2a5c:	9448983a 	sll	r4,r18,r17
    2a60:	2508703a 	and	r4,r4,r20
    2a64:	2448d83a 	srl	r4,r4,r17
                        if (digit <= 9)
    2a68:	208002a8 	cmpgeui	r2,r4,10
    2a6c:	1000091e 	bne	r2,zero,2a94 <alt_printf+0x114>
                            c = '0' + digit;
    2a70:	21000c04 	addi	r4,r4,48
                        alt_putchar(c);
    2a74:	21003fcc 	andi	r4,r4,255
    2a78:	2100201c 	xori	r4,r4,128
    2a7c:	213fe004 	addi	r4,r4,-128
    2a80:	0002ac00 	call	2ac0 <alt_putchar>
                    for (; digit_shift >= 0; digit_shift -= 4)
    2a84:	8c7fff04 	addi	r17,r17,-4
    2a88:	003ff306 	br	2a58 <alt_printf+0xd8>
                    digit_shift = 28;
    2a8c:	04400704 	movi	r17,28
    2a90:	003fee06 	br	2a4c <alt_printf+0xcc>
                            c = 'a' + digit - 10;
    2a94:	210015c4 	addi	r4,r4,87
    2a98:	003ff606 	br	2a74 <alt_printf+0xf4>
                else if (c == 's')
    2a9c:	10801cd8 	cmpnei	r2,r2,115
    2aa0:	103fe01e 	bne	r2,zero,2a24 <alt_printf+0xa4>
                    char *s = va_arg(args, char *);
    2aa4:	84400017 	ldw	r17,0(r16)
    2aa8:	84000104 	addi	r16,r16,4
                    while(*s)
    2aac:	89000007 	ldb	r4,0(r17)
    2ab0:	203fdc26 	beq	r4,zero,2a24 <alt_printf+0xa4>
                      alt_putchar(*s++);
    2ab4:	8c400044 	addi	r17,r17,1
    2ab8:	0002ac00 	call	2ac0 <alt_putchar>
    2abc:	003ffb06 	br	2aac <alt_printf+0x12c>

00002ac0 <alt_putchar>:
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
    2ac0:	defffd04 	addi	sp,sp,-12
    2ac4:	dc000115 	stw	r16,4(sp)
	char        c1 = (char)(c & 0xff);
    return write(STDOUT_FILENO,&c1,1);
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_WRITE_EXTERNS(ALT_STDOUT_DEV);
    char        c1 = (char)(c & 0xff);
    2ac8:	d90000c5 	stb	r4,3(sp)
{
    2acc:	2021883a 	mov	r16,r4

    if (ALT_DRIVER_WRITE(ALT_STDOUT_DEV, &c1, 1, 0) == -1) {
    2ad0:	01000034 	movhi	r4,0
    2ad4:	000f883a 	mov	r7,zero
    2ad8:	01800044 	movi	r6,1
    2adc:	d94000c4 	addi	r5,sp,3
    2ae0:	210b3204 	addi	r4,r4,11464
{
    2ae4:	dfc00215 	stw	ra,8(sp)
    if (ALT_DRIVER_WRITE(ALT_STDOUT_DEV, &c1, 1, 0) == -1) {
    2ae8:	0002b680 	call	2b68 <altera_avalon_jtag_uart_write>
    2aec:	10bfffd8 	cmpnei	r2,r2,-1
    2af0:	1000011e 	bne	r2,zero,2af8 <alt_putchar+0x38>
        return -1;
    2af4:	043fffc4 	movi	r16,-1
    return c;
#else
    return putchar(c);
#endif
#endif
}
    2af8:	8005883a 	mov	r2,r16
    2afc:	dfc00217 	ldw	ra,8(sp)
    2b00:	dc000117 	ldw	r16,4(sp)
    2b04:	dec00304 	addi	sp,sp,12
    2b08:	f800283a 	ret

00002b0c <alt_putstr>:
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided fputs() routine.
 */
int 
alt_putstr(const char* str)
{
    2b0c:	defffe04 	addi	sp,sp,-8
    2b10:	dc000015 	stw	r16,0(sp)
    2b14:	dfc00115 	stw	ra,4(sp)
    2b18:	2021883a 	mov	r16,r4
#ifdef ALT_SEMIHOSTING
    return write(STDOUT_FILENO,str,strlen(str));
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_WRITE_EXTERNS(ALT_STDOUT_DEV);
    return ALT_DRIVER_WRITE(ALT_STDOUT_DEV, str, strlen(str), 0);
    2b1c:	0002bd00 	call	2bd0 <strlen>
    2b20:	01000034 	movhi	r4,0
    2b24:	000f883a 	mov	r7,zero
    2b28:	100d883a 	mov	r6,r2
    2b2c:	800b883a 	mov	r5,r16
    2b30:	210b3204 	addi	r4,r4,11464
#else
    return fputs(str, stdout);
#endif
#endif
}
    2b34:	dfc00117 	ldw	ra,4(sp)
    2b38:	dc000017 	ldw	r16,0(sp)
    2b3c:	dec00204 	addi	sp,sp,8
    return ALT_DRIVER_WRITE(ALT_STDOUT_DEV, str, strlen(str), 0);
    2b40:	0002b681 	jmpi	2b68 <altera_avalon_jtag_uart_write>

00002b44 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
    2b44:	deffff04 	addi	sp,sp,-4
    2b48:	dfc00015 	stw	ra,0(sp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( CPU, CPU);
    2b4c:	0002ba00 	call	2ba0 <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
    2b50:	00800044 	movi	r2,1
    2b54:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
    2b58:	dfc00017 	ldw	ra,0(sp)
    2b5c:	dec00104 	addi	sp,sp,4
    2b60:	f800283a 	ret

00002b64 <alt_sys_init>:

void alt_sys_init( void )
{
    ALTERA_AVALON_TIMER_INIT ( TIMER, TIMER);
    ALTERA_AVALON_JTAG_UART_INIT ( UART, UART);
}
    2b64:	f800283a 	ret

00002b68 <altera_avalon_jtag_uart_write>:
 */

int altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
  unsigned int base = sp->base;
    2b68:	21000017 	ldw	r4,0(r4)
{
    2b6c:	3005883a 	mov	r2,r6

  const char * end = ptr + count;
    2b70:	298d883a 	add	r6,r5,r6

  while (ptr < end)
    2b74:	29800136 	bltu	r5,r6,2b7c <altera_avalon_jtag_uart_write+0x14>
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
      IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, *ptr++);

  return count;
}
    2b78:	f800283a 	ret
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
    2b7c:	20c00137 	ldwio	r3,4(r4)
    2b80:	18ffffec 	andhi	r3,r3,65535
    2b84:	183ffb26 	beq	r3,zero,2b74 <altera_avalon_jtag_uart_write+0xc>
      IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, *ptr++);
    2b88:	28c00007 	ldb	r3,0(r5)
    2b8c:	29400044 	addi	r5,r5,1
    2b90:	20c00035 	stwio	r3,0(r4)
    2b94:	003ff706 	br	2b74 <altera_avalon_jtag_uart_write+0xc>

00002b98 <alt_dcache_flush_all>:
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
    2b98:	f800283a 	ret

00002b9c <alt_icache_flush_all>:
void alt_icache_flush_all (void)
{
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
#endif
}
    2b9c:	f800283a 	ret

00002ba0 <altera_nios2_gen2_irq_init>:
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
    NIOS2_WRITE_IENABLE(0);
    2ba0:	000170fa 	wrctl	ienable,zero
}
    2ba4:	f800283a 	ret

00002ba8 <memcpy>:
    2ba8:	2005883a 	mov	r2,r4
    2bac:	0007883a 	mov	r3,zero
    2bb0:	30c0011e 	bne	r6,r3,2bb8 <memcpy+0x10>
    2bb4:	f800283a 	ret
    2bb8:	28cf883a 	add	r7,r5,r3
    2bbc:	39c00003 	ldbu	r7,0(r7)
    2bc0:	10c9883a 	add	r4,r2,r3
    2bc4:	18c00044 	addi	r3,r3,1
    2bc8:	21c00005 	stb	r7,0(r4)
    2bcc:	003ff806 	br	2bb0 <memcpy+0x8>

00002bd0 <strlen>:
    2bd0:	2005883a 	mov	r2,r4
    2bd4:	10c00007 	ldb	r3,0(r2)
    2bd8:	1800021e 	bne	r3,zero,2be4 <strlen+0x14>
    2bdc:	1105c83a 	sub	r2,r2,r4
    2be0:	f800283a 	ret
    2be4:	10800044 	addi	r2,r2,1
    2be8:	003ffa06 	br	2bd4 <strlen+0x4>
